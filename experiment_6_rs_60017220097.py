# -*- coding: utf-8 -*-
"""Experiment 6 RS 60017220097

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18I0dnTy2ntxLMICEteprNSaLXuDm-Ndy
"""

!pip install pyspark
!pip install surprise

import re
import os
import nltk
from nltk.stem import WordNetLemmatizer
from nltk.corpus import stopwords
import numpy as np
import pandas as pd
from tqdm import tqdm
from scipy import sparse
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD
from sklearn.linear_model import LogisticRegression, Ridge
from matplotlib import pyplot as plt
from tqdm import tqdm
from IPython.display import HTML
from IPython.display import Image as _image

tqdm.pandas()

import datetime

import pyspark
from pyspark.ml import Pipeline
from pyspark import SparkContext
from pyspark.sql import SparkSession
from pyspark.ml.pipeline import PipelineModel
from pyspark.ml.regression import FMRegressor
from pyspark.ml.regression import GBTRegressor
from pyspark.ml.regression import RandomForestRegressor
from pyspark.ml.feature import (StringIndexer, VectorAssembler, VectorIndexer,
                                OneHotEncoder)

from surprise import Reader, Dataset, KNNWithMeans

import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)

# Download nltk requirements
nltk.download('punkt')
nltk.download('wordnet')
nltk.download('stopwords')

class ContextAwareRS:
    """Base class for context-aware recommender systems"""

    def __init__(self, data, context_vars, rating_scale, sim_options=None):
        """Initialize the context aware recommender system given the
        ratings data and context variables
        """
        # Initialize static variables
        self.data = data
        self.context_vars = context_vars
        self.rating_scale = rating_scale
        if sim_options is None:
            self.sim_options = {'name': 'pearson', 'user_based': False,
                                'min_support': 0, 'shrinkage': 0}
        else:
            self.sim_options = sim_options

        # Initialize recsys model
        self.model = None

class ContextPreFiltering(ContextAwareRS):
    """Class for implementing context prefiltering algorithm with a
    neighborhood-based collaborative filtering algorithm
    """

    def __init__(
        self, data, context_vars, rating_scale, sim_options=None, k=None):
        """Initialize the context-prefiltering model"""
        super().__init__(data, context_vars, sim_options)
        if k is None:
            self.k = 5
        else:
            self.k = k

        # Initialize current data - this will be the 'filtered' data
        # based on context
        self.cur_data = None

    def fit(self, context_var_values):
        """Fit a context-aware recsys given context_vars_value"""
        # Get current data based on given context values
        cur_data = self.data.copy()
        for col, val in zip(self.context_vars, context_var_values):
            # If a None value is given, skip that column
            if val is not None:
                cur_data = cur_data.loc[cur_data.loc[:, col] == val]

        # Append to the CPF object for reference later
        self.cur_data = cur_data

        # Perform KNNWithMeans training
        reader = Reader(self.rating_scale)
        dataset = Dataset.load_from_df(self.cur_data.iloc[:, :3], reader)
        knn = KNNWithMeans(k=self.k, sim_options=self.sim_options)
        knn.fit(dataset.build_full_trainset())

        # Save model to object
        self.model = knn

    def show_top_k(self, user_id, top_k=20):
        """Return the context-aware top-k recommendations for user"""
        # Retrieve items not seen by the user
        seen_items = (self.cur_data[self.cur_data.iloc[:, 0] == user_id]
                      .iloc[:, 1].unique())
        #if seen_items == []:
        #    print('no seen movies, so recomms will have same rating')
        #else:
        #    pass
        unseen_items = (
            self.cur_data[~self.cur_data.iloc[:, 1].isin(seen_items)]
            .iloc[:, 1].unique()
        )

        #return seen_items

        # Generate predictions
        predictions = [self.model.predict(user_id, item)
                       for item in unseen_items]

        # Sort predictions based on estimated rating
        return [(prediction.iid, prediction.est)
                for prediction in sorted(predictions,
                                         key=lambda x: -x.est)][:top_k]

class ContextPostFiltering(ContextAwareRS):
    """Class for implementing context postfiltering algorithm with a
    neighborhood-based collaborative filtering algorithm
    """

    def __init__(
        self, data, context_vars, rating_scale, sim_options=None, k=None):
        """Initialize the context-prefiltering model"""
        super().__init__(data, context_vars, sim_options)
        if k is None:
            self.k = 5
        else:
            self.k = k

        # Initialize filter matrix. This will be used to filter the
        # resulting ratings at prediction time
        self.cur_data = None
        self.filter_matrix = None

    def fit(self, context_var_values, min_rating=3):
        """Fit a context-aware recsys given context_vars_value"""
        # Get current data based on given context values
        cur_data = self.data.copy()
        for col, val in zip(self.context_vars, context_var_values):
            # If a None value is given, skip that column
            if val is not None:
                cur_data = cur_data.loc[cur_data.loc[:, col] == val]
        self.cur_data =cur_data

        # Solve for the filter matrix. Here, we take P(*, i, c) as the
        # ratio between users who rate the movie with
        # stars > min_rating, over the total number of users.
        filter_matrix = cur_data.groupby('movieid').rating.apply(
            lambda x: (x >= min_rating).sum() / len(x)
        )
        self.filter_matrix = filter_matrix

        # Aggregate data into two-dimensional ratings matrix
        aggregate_data = (self.data.groupby(self.data.columns[:2].tolist())
                          .rating.mean().reset_index())

        # Perform KNNWithMeans training
        reader = Reader(self.rating_scale)
        dataset = Dataset.load_from_df(aggregate_data, reader)
        knn = KNNWithMeans(k=self.k, sim_options=self.sim_options)
        knn.fit(dataset.build_full_trainset())

        # Save model to object
        self.model = knn

    def show_top_k(self, user_id, top_k=20):
        """Return the context-aware top-k recommendations for user"""
        # Retrieve items not seen by the user
        seen_items = (self.cur_data[self.cur_data.iloc[:, 0] == user_id]
                      .iloc[:, 1].unique())
        if seen_items == []:
            print('no seen movies, so recomms will have same rating')
        else:
            pass
        unseen_items = (
            self.cur_data[~self.cur_data.iloc[:, 1].isin(seen_items)]
            .iloc[:, 1].unique()
        )

        # Generate predictions
        predictions = pd.DataFrame([self.model.predict(user_id, item)
                                    for item in unseen_items])
        predictions = predictions.set_index(predictions.columns[1]).est

        # Perform the post-filtering process
        predictions = ((predictions * self.filter_matrix)
                       .sort_values(ascending=False))

        # Sort predictions based on estimated rating
        return predictions[:top_k]

class ContextualModeling(ContextAwareRS):
    """Class for implmenting contextual modeling using factorization
    machines
    """

    def __init__(self, data, context_vars):
        """Initialize the contextual modeling recommender system"""
        super().__init__(data, context_vars, None)

    def fit(self):
        """Fit given the context variable values"""
        # Set the pipeline for the Factorization machines
        pipe = Pipeline(stages=[
            # Create string indices for each string variable
            StringIndexer(
                inputCols=['userid', 'movieid'],
                outputCols=['useridIndex', 'movieidIndex']),

            # One hot encode variables
            OneHotEncoder(
                inputCols=['useridIndex', 'movieidIndex', 'age',
                           'occupations'],
                outputCols=['userID', 'movieID', 'ageID', 'occID']),

            # Assemble onto one vector
            VectorAssembler(
                inputCols=['userID', 'movieID', 'ageID', 'gender', 'occID'],
                outputCol='features', handleInvalid='skip'),

            # Train a FM model
            FMRegressor(
                featuresCol='features', labelCol='rating', stepSize=0.001)
        ])

        # Create spark data frame then fit the model to it
        sdf = spark.createDataFrame(self.data)
        model = pipe.fit(sdf)

        # Save the model to object
        self.model = model

    def show_top_k(self, user_id, context_var_values, top_k=20):
        """Return the context-aware top-k recommendations for user"""
        # Get current data based on given context values
        cur_data = self.data.copy()
        for col, val in zip(self.context_vars, context_var_values):
            # If a None value is given, skip that column
            if val is not None:
                cur_data = cur_data.loc[cur_data.loc[:, col] == val]

        # Retrieve items not seen by the user
        seen_items = (cur_data[cur_data.iloc[:, 0] == user_id].iloc[:, 1]
                      .unique())
        unseen_items = (cur_data[~cur_data.iloc[:, 1].isin(seen_items)]
                        .iloc[:, 1].unique())

        # Setup test data frame
        test_df = pd.DataFrame({'movieid': unseen_items})
        test_df.loc[:, self.data.columns[0]] = user_id
        test_df.loc[:, self.context_vars[0]] = context_var_values[0]
        test_df.loc[:, self.context_vars[1]] = context_var_values[1]
        test_df.loc[:, self.context_vars[2]] = context_var_values[2]
        test_sdf = spark.createDataFrame(test_df)

        # Get predictions
        predictions = (self.model.transform(test_sdf)
                       .select(['movieid', 'prediction'])
                       .toPandas().sort_values('prediction', ascending=False))

        # Sort predictions based on estimated rating
        return predictions[:top_k]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 1. Snippet of movies.csv
</b></p>'''))
movies = pd.read_csv('movies.csv')
display(movies.head())

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 2. Snippet of users.csv
</b></p>'''))
users = pd.read_csv('users.csv')
display(users.head())

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 3. Snippet of ratings.csv
</b></p>'''))
ratings = pd.read_csv('ratings.csv')
display(ratings.head())

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 4. Snippet of merged dataframes
</b></p>'''))

# merge the user ratings and the movie information
merged = pd.merge(ratings, movies, on='movieid')

# merge it into the user information
final = pd.merge(merged, users, on='userid')

display(final.head())

# first user's movie preferences

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 6. Maria's Seen & Rated Movies
</b></p>'''))

display(final[final.userid == 3388][['rating', 'title']])

# second user's movie preferences

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 7. Jose's Seen & Rated Movies
</b></p>'''))

display(final[final.userid == 1406][['rating', 'title']])

# renaming list

rename = {"occupations": {0: "other", 1: "academic/educator", 2: "artist",
                          3: "clerical/admin",  4: "college/grad student",
                          5: "customer service",  6: "doctor/health care",
                          7: "executive/managerial", 8: "farmer",
                          9: "homemaker", 10: "K-12 student", 11: "lawyer",
                          12: "programmer", 13: "retired",
                          14: "sales/marketing", 15: "scientist",
                          16: "self-employed", 17: "technician/engineer",
                          18: "tradesman/craftsman", 19: "unemployed",
                          20: "writer"},
         "age": {1: "Under 18", 18: "18-24", 25: "25-34", 35: "35-44",
                 45: "45-49", 50: "50-55", 56: "56+"}}

df_movies = movies.copy()
display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 1. Top 10 genre with largest movie count.
</b></center>'''))
genre = (df_movies.genre.str.split(',')
                  .apply(lambda x: [re.sub(r'[^\w\s]', '', i) for i in x])
                  .explode()
                  .value_counts()[:10][::-1])

display(HTML(f'''<h3 style="text-align:center">
                Most of the movies in MovieLens have
                <b style="color:{"darkorange"}">
                drama</b> genre
                </h3>'''))

plt.figure(figsize=(10, 6))
genre.plot.barh(color= ['lightgray'] * (len(genre) - 1) + ['darkorange'])
plt.xlabel("Number of Movies", fontsize=15)
plt.ylabel("Genre", fontsize=15)
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.show()

genre = (final.genre.str.split(',')
                  .apply(lambda x: [re.sub(r'[^\w\s]', '', i) for i in x])
                  .explode()
                  .value_counts()[:10][::-1])
display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 2. Top 10 genre with most rated counts.
</b></center>'''))

display(HTML(f'''<h3 style="text-align:center">
                Most rated movies of MovieLens
                have<b style="color:{"orange"}">
                comedy</b> genre
                </h3>'''))


plt.figure(figsize=(10, 6))
genre.plot.barh(color= ['lightgray'] * (len(genre) - 3) + ['darkorange']
                + ['lightgray'] + ['darkorange'])
plt.xlabel("Number of Rated Movies", fontsize=15)
plt.ylabel("Genre", fontsize=15)
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.show()

display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 3. Top 10 genre with highest average ratings.
</b></center>'''))

display(HTML(f'''<h3 style="text-align:center">
                <b style="color:{"orange"}">
                Film Noir</b> has the highest average ratings
                </h3>'''))


plt.figure(figsize=(10, 6))

eda = final.copy()
eda['genre'] = eda.genre.apply(eval)
(eda.loc[:, ['genre', 'rating']].explode('genre')
   .groupby('genre')['rating'].mean()
   .sort_values(ascending=False)[:10][::-1]
   .plot.barh(color= ['lightgray'] * (len(genre) - 4) + ['darkorange']
                     + ['lightgray'] * 2 + ['darkorange']))
plt.xlabel("Ratings", fontsize=15)
plt.ylabel("Genre", fontsize=15)
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.show()

# plot user by gender

user_plot = users.replace(rename)

display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 4. User Distribution per Gender.
</b></center>'''))

gender_plot = (user_plot.gender.value_counts(ascending=True))

display(HTML(f'''<h3 style="text-align:center">
                Number of users based on<b style="color:{"orange"}">
                gender</b>
                </h3>'''))


plt.figure(figsize=(10, 6))
gender_plot.plot.barh(color= ['darkgray'] * (len(gender_plot) - 1) + ['darkorange'])
plt.xlabel("Number of Users", fontsize=15)
plt.ylabel("Gender", fontsize=15)
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.show()

# plot user by age

age_plot = (user_plot.age.value_counts(ascending=True))

display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 5. User Distribution per Age Bracket.
</b></center>'''))

display(HTML(f'''<h3 style="text-align:center">
                Number of users based on<b style="color:{"orange"}">
                age bracket</b>
                </h3>'''))


plt.figure(figsize=(10, 6))
age_plot.plot.barh(color= ['darkgray'] * (len(age_plot) - 1) + ['darkorange'])
plt.xlabel("Number of Users", fontsize=15)
plt.ylabel("Age Bracket", fontsize=15)
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.show()

# plot user by occupation

occ_plot = (user_plot.occupations.value_counts(ascending=True))

display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 6. User Distribution per Occupation.
</b></center>'''))

display(HTML(f'''<h3 style="text-align:center">
                Number of users based on<b style="color:{"orange"}">
                occupation</b>
                </h3>'''))


plt.figure(figsize=(10, 6))
occ_plot.plot.barh(color= ['darkgray'] * (len(occ_plot) - 1) + ['darkorange'])
plt.xlabel("Number of Users", fontsize=15)
plt.ylabel("Occupation", fontsize=15)
ax = plt.gca()
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
plt.show()

fig, ax = plt.subplots(1, 1, figsize=(8,6))

display(HTML('''<center style="font-size:12px;font-style:default;"><b>
Figure 7. Average Ratings per Category.
</b></center>'''))

display(HTML(f'''<h3 style="text-align:center">
                <b style="color:{"darkorange"}">
                Female</b> and <b style="color:{"darkorange"}">Older</b>
                generation tend to rate higher
                </h3>'''))

(final.groupby('gender')['rating'].mean()
 .sort_values()
 .plot.barh(color=['lightgray','darkorange'], xlim=(3,4), ax=ax))

ax.set_xlabel("Rating", fontsize=15)
ax.set_ylabel("Gender", fontsize=15)
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)


fig, ax = plt.subplots(1, 2, figsize=(25,8))

(final.groupby('age')['rating'].mean()
 .sort_values().plot.barh(ax=ax[0], color= ['lightgray'] *
                          (len(genre) - 4) + ['darkorange']
                          + ['lightgray'] * 2 + ['orange'], xlim=(3,4)))
ax[0].set_xlabel("Rating", fontsize=15)
ax[0].set_ylabel("Age group", fontsize=15)
ax[0].spines['top'].set_visible(False)
ax[0].spines['right'].set_visible(False)

df = final.copy()
df['occupations'] = df.occupations.apply(lambda x: rename['occupations'][x])
(df.groupby('occupations')['rating'].mean()
 .sort_values(ascending=False)[:10][::-1]
 .plot.barh(ax=ax[1],color=['lightgray']  * 9 + ['darkorange'], xlim=(3,4)))
ax[1].set_xlabel("Rating", fontsize=15)
ax[1].set_ylabel("Age group", fontsize=15)
ax[1].spines['top'].set_visible(False)
ax[1].spines['right'].set_visible(False)

fig.tight_layout()

#df = pd.read_csv('final.csv')
df_movies = pd.read_csv('movies.csv')

def preprocess_movies(df_movies):
    """ Preprocess the content metadata of the movie

    Parameters
    ===========
    df_movies    :    pandas.DataFrame
                      database

    Returns
    ===========
    preprocess_movies   :  tuple
                           tuple of database and tfidf transformed data
    """
    df_movies['title_genre'] = df_movies.title +  ' '  + df_movies.genre
    df_movies['title_genre'] = df_movies.title_genre.str.replace(r'[^\w\s]',
                                                            '', regex=True)

    # tokenize
    tokenize = df_movies.title_genre.apply(nltk.word_tokenize)

    # casefold
    lower_case = tokenize.apply(lambda x:list(map(lambda y: y.casefold(), x)))


    # lemmatize
    lemmatizer = WordNetLemmatizer()
    lemmatize = lower_case.apply(lambda x: list(map(lemmatizer.lemmatize,
                                                             x)))

    # remove stopwords
    stop_words = set(stopwords.words('english'))
    filtered_stopwords = lemmatize.apply(lambda x:
                                        list(filter(lambda y: y
                                                not in stop_words,
                                                              x)))

    # filter words with less than 3 character length
    filtered_words = filtered_stopwords.apply(lambda x:
                                                       list(filter(lambda y:
                                                                   len(y) > 3,
                                                                   x)))

    df_movies['clean'] = (filtered_words.apply(' '.join))

    tfidf_vectorizer = TfidfVectorizer(token_pattern=r'\b[a-z]+\b',
                                       ngram_range=(1, 2),
                                       max_df=0.8,
                                       min_df=0.01)


    tfidf = tfidf_vectorizer.fit_transform(df_movies.clean)

    svd = TruncatedSVD(n_components=20, random_state=0)
    X_new = svd.fit_transform(tfidf)

    return df_movies, X_new

def content_recom(user, df, df_movies, X_new, top_k=10, **kwargs):
    """ Perform content model based recommender sytem for a single user

    Parameters
    ===========
    user        :    int
                     user id
    df          :    pandas.DataFrame
                     full database
    df_movies   :    pandas.DataFrame
                     movies database
    X_new       :    numpy.ndarray
                     tfidf transformed features
    top_k       :    int
                     number of recommendations

    Returns
    ===========
    content_recom  : pandas.DataFrame
                     dataframe of recommended movies
    """
    if 'pre' in kwargs.keys():
        df = df[df[kwargs['context_var']] == kwargs['context_var_value']]
        df = df.reset_index()

    recom = {}
    df_user = df[df.userid==user].copy().sort_values(by='movieid')
    profile = {
    'user': df_user.userid.unique()[0],
    'gender' : df_user.gender.unique()[0],
    'timestamp' : None,
    'age' : df_user.age.unique()[0],
    'occupations' : df_user.occupations.unique()[0],
    'zip' : df_user.zip.unique()[0],
    }

    df_out = pd.DataFrame()

    seen = set(df_user.movieid)
    unseen = set(df.movieid) - seen
    df_movies = df_movies.sort_values(by='movieid')
    movie_index_seen = df_movies[df_movies.movieid.isin(
            sorted(seen))].index

    X = X_new[movie_index_seen]
    y = df_user.rating.to_numpy()
    movie_index_unseen = df_movies[df_movies.movieid.isin(
        sorted(unseen))].index
    X_test = X_new[movie_index_unseen, :]
    model = Ridge(random_state=143)

    try:
        model.fit(X, y)
        new_rating = model.predict(X_test)
        limit = len(new_rating) if 'post' in kwargs.keys() else top_k
        top_recom = np.argsort(new_rating, kind='mergesort')[::-1][:limit]
        top_item = np.array(sorted(unseen))[top_recom]
        for i, item in enumerate(top_item):
            temp = profile.copy()
            temp['movieid'] = item
            temp['title'] = df_movies[df_movies.movieid ==
                                      item].title.to_list()[0]
            temp['genre'] = df_movies[df_movies.movieid ==
                                      item].genre.to_list()[0]
            temp['rating'] = new_rating[top_recom[i]]
            df_out = df_out.append(pd.DataFrame(temp,
                                   index=[0])).reset_index(drop=True)

    except ValueError:
        pass

    if 'post' in kwargs.keys():
        df_out = df_out[df_out[kwargs['context_var']] ==
                        kwargs['context_var_value']]

    return df_out[:top_k]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 8. Maria's Recommended movies based on content metadata
</b></p>'''))

df_movies, X_new = preprocess_movies(df_movies)
display(content_recom(3388, df, df_movies, X_new).iloc[:, [0, 6, 7, 8]])

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 9. Jose's Recommended movies based on content metadata
</b></p>'''))

df_movies, X_new = preprocess_movies(df_movies)
display(content_recom(1406, df, df_movies, X_new).iloc[:, [0, 6, 7, 8]])

# prepare matrix for context-aware RS

sample = final.copy()
sample = sample[['userid', 'movieid', 'rating',
                 'gender', 'age', 'occupations']]
encode_nums = {"gender":     {"M": 0, "F": 1},
               "age": {1 : 0, 18 : 1, 25 : 2, 35 : 3,
                       45 : 4, 50 : 5, 56 : 6 }}
sample = sample.replace(encode_nums)

# recommendations with context filters

cpre = ContextPreFiltering(sample, ['gender'], (1, 5))
cpre.fit([1])
cpre_recommendations1 = cpre.show_top_k(3388)
recom_table = final.loc[[i[0] for i in cpre_recommendations1], ['title']]
recom_table['ratings'] = [i[1] for i in cpre_recommendations1]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 10. Maria's Recommendations - Gender Filter (Female)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpre = ContextPreFiltering(sample, ['age'], (1, 5))
cpre.fit([2])
cpre_recommendations1 = cpre.show_top_k(3388)
recom_table = final.loc[[i[0] for i in cpre_recommendations1], ['title']]
recom_table['ratings'] = [i[1] for i in cpre_recommendations1]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 11. Maria's Recommendations - Age Filter (25-34 years old)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpre = ContextPreFiltering(sample, ['gender'], (1, 5))
cpre.fit([0])
cpre_recommendations1 = cpre.show_top_k(1406)
recom_table = final.loc[[i[0] for i in cpre_recommendations1], ['title']]
recom_table['ratings'] = [i[1] for i in cpre_recommendations1]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 12. Jose's Recommendations - Gender Filter (Male)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpre = ContextPreFiltering(sample, ['age'], (1, 5))
cpre.fit([2])
cpre_recommendations1 = cpre.show_top_k(1406)
recom_table = final.loc[[i[0] for i in cpre_recommendations1], ['title']]
recom_table['ratings'] = [i[1] for i in cpre_recommendations1]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 13. Jose's Recommendations - Age Filter (25-34 years old)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpre = ContextPreFiltering(sample, ['occupations'], (1, 5))
cpre.fit([4])
cpre_recommendations1 = cpre.show_top_k(1406)
recom_table = final.loc[[i[0] for i in cpre_recommendations1], ['title']]
recom_table['ratings'] = [i[1] for i in cpre_recommendations1]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 14. Jose's Recommendations - Occupation Filter (Grad Student)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpost = ContextPostFiltering(sample, ['gender', 'age', 'occupations'], (1, 5))
cpost.fit([1, 2, 1])
cpost_recommendations1 = cpost.show_top_k(3388)
recom_table = final.loc[[i for i in cpost_recommendations1.index], ['title']]
recom_table['ratings'] = [cpost_recommendations1[i] for
                          i in cpost_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 19. Maria's Recommendations - Gender, Age & Occupation Filter
(Female, 25-34 years old, Academe)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpost = ContextPostFiltering(sample, ['gender'], (1, 5))
cpost.fit([0])
cpost_recommendations1 = cpost.show_top_k(1406)
recom_table = final.loc[[i for i in cpost_recommendations1.index], ['title']]
recom_table['ratings'] = [cpost_recommendations1[i] for
                          i in cpost_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 20. Jose's Recommendations - Gender Filter (Male)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpost = ContextPostFiltering(sample, ['age'], (1, 5))
cpost.fit([2])
cpost_recommendations1 = cpost.show_top_k(1406)
recom_table = final.loc[[i for i in cpost_recommendations1.index], ['title']]
recom_table['ratings'] = [cpost_recommendations1[i] for
                          i in cpost_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 21. Jose's Recommendations - Age Filter (25-34 years old)
</b></p>'''))

display(recom_table)

# recommendations with context filters

cpost = ContextPostFiltering(sample, ['occupations'], (1, 5))
cpost.fit([4])
cpost_recommendations1 = cpost.show_top_k(1406)
recom_table = final.loc[[i for i in cpost_recommendations1.index], ['title']]
recom_table['ratings'] = [cpost_recommendations1[i] for
                          i in cpost_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 22. Jose's Recommendations - Occupation Filter (Grad Student)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cpost = ContextPostFiltering(sample, ['gender', 'age'], (1, 5))
cpost.fit([0, 2])
cpost_recommendations1 = cpost.show_top_k(1406)
recom_table = final.loc[[i for i in cpost_recommendations1.index], ['title']]
recom_table['ratings'] = [cpost_recommendations1[i] for
                          i in cpost_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 23. Jose's Recommendations - Gender & Age Filter (Male, 25-34 years old)
</b></p>'''))

display(recom_table)

# recommendations with context filters

cpost = ContextPostFiltering(sample, ['gender', 'age', 'occupations'], (1, 5))
cpost.fit([0, 2, 4])
cpost_recommendations1 = cpost.show_top_k(1406)
recom_table = final.loc[[i for i in cpost_recommendations1.index], ['title']]
recom_table['ratings'] = [cpost_recommendations1[i] for
                          i in cpost_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 24. Jose's Recommendations - Gender, Age & Occupation Filter
(Male, 25-34 years old, Grad Student)
</b></p>'''))

display(recom_table)

# setup spark
config = pyspark.SparkConf().setAll([('spark.driver.memory', '12g')])
sc = SparkContext(conf=config)
spark = SparkSession.builder.config(conf=config).getOrCreate()
spark.sparkContext.setLogLevel("ERROR")

# recommendations with context filters

cm = ContextualModeling(sample, ['gender', 'age', 'occupations'])
cm.fit()
cm_recommendations1 = cm.show_top_k(3388, [1, 2, 1])
recom_table = final.loc[[i for i in cm_recommendations1.index], ['title']]
recom_table['ratings'] = [cm_recommendations1['prediction'][i] for
                          i in cm_recommendations1.index]

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 25. Maria's Recommendations - Gender, Age & Occupation Filter
(Female, 25-34 years old, Academe)
</b></p>'''))
display(recom_table)

# recommendations with context filters

cm = ContextualModeling(sample, ['gender', 'age', 'occupations'])
cm.fit()
cm_recommendations1 = cm.show_top_k(1406, [0, 2, 4])
recom_table = final.loc[[i for i in cm_recommendations1.index], ['title']]
recom_table['ratings'] = [cm_recommendations1['prediction'][i] for
                          i in cm_recommendations1.index]
display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 26. Jose's Recommendations - Gender, Age & Occupation Filter
(Male, 25-34 years old, Grad Student)
</b></p>'''))
display(recom_table)

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 27. Maria's Recommended movies based on content metadata
and gender context
</b></p>'''))

# recommendations with context filters
cpost = ContextPostFiltering(sample, ['gender'], (1, 5))
cpost.fit([1])
cpost_recommendations1 = cpost.show_top_k(3388, top_k=1000)
post = pd.DataFrame(cpost_recommendations1)
post.columns = ['post_ratings']

# content
df_movies, X_new = preprocess_movies(df_movies)
cont = content_recom(3388, df, df_movies, X_new, top_k=100)
cont = cont.set_index('movieid')

mix = pd.merge(cont, post, left_index=True, right_index=True)

mix['rating'] = (mix.rating-mix.rating.min()
                  /(mix.rating.max()-mix.rating.min()))
mix['post_ratings'] = ((mix.post_ratings-mix.post_ratings.min())
                       /(mix.post_ratings.max()-mix.post_ratings.min()))
mix['mix_ratings'] = mix.rating * 0.5 + mix.post_ratings * 0.5

display(mix.sort_values(by='mix_ratings',
                        ascending=False)[:20].iloc[:, [0, 6]])

display(HTML('''<p style="font-size:12px;font-style:default;"><b>
Table 28. Jose's Recommended movies based on content metadata
and gender context
</b></p>'''))

# recommendations with context filters
cpost = ContextPostFiltering(sample, ['gender'], (1, 5))
cpost.fit([1])
cpost_recommendations1 = cpost.show_top_k(3388, top_k=1000)
post = pd.DataFrame(cpost_recommendations1)
post.columns = ['post_ratings']

# content
df_movies, X_new = preprocess_movies(df_movies)
cont = content_recom(1406, df, df_movies, X_new, top_k=100)
cont = cont.set_index('movieid')

mix = pd.merge(cont, post, left_index=True, right_index=True)

mix['rating'] = (mix.rating-mix.rating.min()
                  /(mix.rating.max()-mix.rating.min()))
mix['post_ratings'] = ((mix.post_ratings-mix.post_ratings.min())
                       /(mix.post_ratings.max()-mix.post_ratings.min()))
mix['mix_ratings'] = mix.rating * 0.5 + mix.post_ratings * 0.5

display(mix.sort_values(by='mix_ratings',
                        ascending=False)[:20].iloc[:, [0, 6]])

